<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rethinking Restrictions: From SQL to Graph</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 960px;
      margin: 40px auto;
      line-height: 1.6;
      padding: 0 20px;
    }
    h1, h2, h3 {
      color: #222;
    }
    code {
      background: #f2f2f2;
      padding: 2px 4px;
      border-radius: 3px;
      font-family: monospace;
    }
    pre {
      background: #f8f8f8;
      padding: 10px;
      overflow-x: auto;
    }
    img {
      max-width: 100%;
      margin: 20px 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }
    th {
      background: #f0f0f0;
    }
  </style>
</head>
<body>

<h1>Rethinking Restrictions: From SQL to Graph</h1>

<h2>Introduction</h2>`
<p>
  This post explains the evolution of a mission-critical system built to enforce hiring restrictions at a global executive recruitment firm. It dives into the technical challenges of modeling restrictions across large hierarchical companies and why traditional relational models proved inadequate.

</p>

<p>
  A “restriction” refers to a contractual or ethical limitation on who can be contacted. These fall into categories such as “Do Not Contact” (e.g., for legal reasons), “Reservation” (temporary holds), or “Off-Limits” (e.g., due to recent business engagements).
</p>
<p>One of the most complex projects I worked on was the Restrictions system at a global executive recruitment firm. </p> 
<p>The system was designed to enforce legal and reputational safeguards by ensuring the firm did not contact individuals covered by contractual hiring restrictions. </p>
<p>For example, if hired to find a CEO for a multinational bank like Barclays, the firm might agree not to approach any marketing managers globally for a set duration.
</p>
<p>While the front-end representation was a simple restriction flag, the back-end logic was highly complex. The system had to process deeply nested company hierarchies and normalized relational database structures, tracking roles, departments, and job histories of individuals.

  <img src="assets/company-structure.png" alt="Company Structure">

  <section id="example-walkthrough">
    <h2>Example Walkthrough: Evaluating a Restriction</h2>
  
    <p>Let’s walk through a real-world scenario to illustrate how the current system determines whether a candidate is restricted from contact.</p>
  
    <h3>Scenario</h3>
    <p>Your firm has been engaged to find the new <strong>Chief Marketing Officer</strong> for a major client: <strong>Barclays PLC</strong>. Before reaching out to any candidates, the system must confirm that the person is not restricted. One of the potential candidates is <strong>Jane Doe</strong>, currently a <em>Marketing Director at Barclays UK</em>.</p>
  
    <h3>Company Hierarchy</h3>
    <pre><code>Barclays PLC
  ├── Barclays UK (Tier 1)
  │   ├── Barclays Digital Marketing (Tier 2)
  │   └── Barclays Consumer Banking (Tier 2)
  └── Barclays US (Tier 1)
      ├── Barclays Wealth Management (Tier 2)
  </code></pre>
    <p>Jane Doe is employed by <strong>Barclays Digital Marketing</strong>, two levels down from the global parent.</p>
  
    <h3>Step-by-Step Evaluation in SQL</h3>
    <ol>
      <li><strong>Start at the Candidate’s Employer:</strong> The system identifies that Jane is employed at "Barclays Digital Marketing".</li>
      <li><strong>Climb the Hierarchy:</strong> A recursive stored procedure walks up the hierarchy from "Barclays Digital Marketing" → "Barclays UK" → "Barclays PLC".</li>
      <li><strong>Fetch Restriction Records:</strong> For each company in this chain, the system joins against the <code>Restrictions</code>, <code>Reservations</code>, and <code>DoNotContact</code> tables.</li>
      <li><strong>Evaluate Roles and Time Windows:</strong>
        <ul>
          <li>Checks if marketing roles are restricted at any level of the hierarchy.</li>
          <li>Verifies that the restriction is active and not expired.</li>
          <li>Matches Jane’s job title or function against exclusion rules.</li>
          <li>Considers whether she was involved in recent placements triggering a cooling-off period.</li>
        </ul>
      </li>
      <li><strong>Return Restriction Status:</strong> If any restriction condition is met at any level, Jane is <strong>flagged as restricted</strong>, and the consultant is warned not to proceed.</li>
    </ol>
  
    <h3>Why This Is a Problem</h3>
    <ul>
      <li>This recursive join occurs <strong>millions of times per day</strong>, even if nothing has changed.</li>
      <li>Pattern checks are repeated constantly.</li>
      <li>Companies like Barclays can have <strong>10+ layers</strong> of hierarchy, increasing compute cost.</li>
      <li>Logic is fragmented across tables and functions, making it <strong>hard to maintain and optimize</strong>.</li>
    </ul>
  </section>
  
















</p><p>  Restrictions could be set at individual or company-wide levels, requiring continuous post-processing jobs to check for changes like role movements, departures, or new assignments.
  
  This processing logic had to account for both company-down and person-up evaluations, and was prone to issues like recursive references and long-running SQL Server jobs, which sometimes caused performance bottlenecks or P1 incidents. </p> 
  
  <p>The complexity and scale occasionally led to delays, risking consultants contacting restricted individuals before flags were updated—potentially breaching legal contracts.. The failures weren't caused by technical debt — they stem from fundamental design decisions. I originally architected Restrictions as a relational model within SQL Server, but as the product and its business logic have evolved, I’ve come to the conclusion that we are using the wrong technology for the job.</p>


  <section id="csharp-cumbersome">
    <h3>❗ Why This Is Cumbersome to Do in C#</h3>
    <p>
      At first glance, it might seem tempting to replicate the SQL restriction logic in C# using Entity Framework or raw SQL queries. However, this quickly becomes impractical and difficult to maintain for several reasons:
    </p>
    <ul>
      <li>
        <strong>Object-Relational Mapping Complexity:</strong> Modeling recursive company hierarchies in C# via an ORM like Entity Framework leads to deep nesting, circular references, or inefficient lazy loading. These relationships are a poor fit for traditional object graphs.
      </li>
      <li>
        <strong>Manual Recursion and State Tracking:</strong> Tree traversal in C# must be implemented by hand, including mechanisms to prevent infinite loops or stack overflows. This adds considerable boilerplate and risk of logic errors.
      </li>
      <li>
        <strong>Business Rule Explosion:</strong> Each restriction type has different criteria (e.g., title, tenure, function, location). This leads to scattered logic across multiple classes or deeply nested <code>if</code>/<code>else</code> blocks, making testing and validation difficult.
      </li>
      <li>
        <strong>Loss of Declarative Simplicity:</strong> SQL allows expressing queries in a concise, declarative form. C# forces you into an imperative approach, where each step and condition must be explicitly coded. This bloats the codebase and reduces clarity.
      </li>
      <li>
        <strong>Performance Bottlenecks:</strong> What SQL can do in a set-based operation, C# may attempt to do with row-by-row evaluation. This N+1 problem severely impacts performance at scale—especially when dealing with millions of candidates and daily evaluations.
      </li>
    </ul>
    <p>
      While C# offers flexibility, its use here would shift complexity from the data model into application logic—introducing new classes of bugs, reducing transparency, and making the system harder to evolve.
    </p>
  </section>
  



<p>In this post, I walk through the evolution of Restrictions, the current architecture, and the challenges that arise from trying to simulate graph traversal using a relational model. Then, I present a compelling case for moving Restrictions into a graph database — a model far more suited to the relationships and reasoning this product depends on.</p>

<h2>Background</h2>
<p>Restrictions is one of the most business-critical features within Quest. It protects us from reputational and legal risk by ensuring our consultants do not engage with individuals who are off-limits, under embargo, or already engaged. It began with a simple goal — determine if someone is restricted — but the business logic has expanded significantly. We now support over 22 types of restrictions and must handle complex cases like reservations, job functionality, company structures, and M&A-driven hierarchy changes.</p>

<p>The original system relied on SQL stored procedures to infer restriction state by joining large numbers of tables with temporal and conditional logic. This worked when the problem was small. But today, it’s clear that SQL Server is fundamentally unsuited to accurately, consistently, and efficiently answering the question: <em>“Is this person restricted right now?”</em></p>

<h2>Current Architecture and Challenges</h2>
<p>The current system uses two master stored procedures — one for people, one for companies — which recursively join tables, traverse parent/child company relationships, and recalculate every restriction every time. This includes:</p>
<ul>
  <li>OffLimits rules based on company, job function, or job category</li>
  <li>Reservations linked via assignments or roles</li>
  <li>Direct Restrictions like Do Not Contact or Conversation Required</li>
</ul>


<h2>Simple Question</h2>

<p>Asking asimple question such as - is a given person restricted based upon their status within a company assessment led to the following SQL logic being executed</p>


<img src="assets/existing-logic.png" alt="Company Structure">

<p>Within this query, we had 9 tables, 19 business process categories, 2 business process role status category codes, 2 personrestrictioncategory codes
</p>

<p>This type of logic was typical of using TSQL to solve the problem - bear in mind that there were 21 types of restriction to apply to a person. So any lateral career move by an individual resulted in 21 stored procedures like this being executed, and there were 10s of thousands of Person changes in our system every day</p>

<p>I performed an analysis that revealed that on a typical day, we had 25 million invocations of one of our central SQL Functions used in restrictions, and it resulted in just 373 updates to our system</p>

<img src="assets/twenty-five-million-executions.png" alt="twenty million executions">



<p>This approach has major downsides:</p>
<ul>
  <li>Recalculations happen even when nothing has changed</li>
  <li>Jobs and roles are joined repeatedly with filters and flags</li>
  <li>Historical data and current state coexist in the same tables</li>
  <li>Company structure traversal is recursive and expensive (e.g. Barclays has 495 children)</li>
</ul>

<p>We tried to patch over the flaws with a “real-time badge” system, but that in itself has added 247,000 entries to a tracking table in production. These layers of indirection, compensating logic, and runtime patching are signals of a flawed design pattern.</p>

<h2>What Makes This Hard</h2>
<p>Restrictions logic requires graph traversal. Whether it’s checking if a job falls under a company-wide off-limit, or whether a person’s placement still binds them within a company family tree, the underlying data model is a <strong>graph of entities and relationships</strong>. But in SQL Server, those relationships are implicit, not native. We simulate them through joins and recursive CTEs.</p>

<p>Every production incident over the past three years has followed a familiar theme: the system fails to recognize a restriction due to complexity in traversing jobs, companies, and roles. These failures have high reputational impact and take considerable effort to debug.</p>

<h2>Why Graph?</h2>
<p>Graph databases are purpose-built for these kinds of problems. Graph databases hold the relationships between data as a priority
  Instead of joining rows, they follow relationships. Nodes represent people, companies, jobs, restrictions. Relationships like <code>WORKS_AT</code>, <code>PLACED_IN</code>, or <code>COVERED_BY</code> explicitly model the connections we care about.</p>

<p>Traversal in a graph is lightweight and constant-time per hop — whether you're 2 or 20 levels deep in a company structure. We don’t have to re-derive anything. We just ask: <em>“Can I navigate from this Person node to a Restriction node?”</em> If yes, the person is restricted.</p>

<h3>Benefits</h3>
<ul>
  <li>Simplified logic — no more multi-join SQL</li>
  <li>Accurate modeling of business rules</li>
  <li>Linear scaling with complexity</li>
  <li>Real-time restriction status without recalculation</li>
  <li>Eliminates need to persist interpreted state (badge snapshot)</li>
</ul>



<h2>SQL vs Graph: A Side-by-Side Comparison</h2>
<table>
  <thead>
    <tr>
      <th>Aspect</th>
      <th>Relational (SQL Server)</th>
      <th>Graph (Neo4j)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Data Structure</td>
      <td>Tables joined by foreign keys</td>
      <td>Nodes and relationships</td>
    </tr>
    <tr>
      <td>Traversal</td>
      <td>Requires recursive joins and CTEs</td>
      <td>Direct and native — follow edges</td>
    </tr>
    <tr>
      <td>Restriction Evaluation</td>
      <td>Recalculated with every query or persisted snapshot</td>
      <td>Inferred instantly from graph structure</td>
    </tr>
    <tr>
      <td>Debugging</td>
      <td>Hard to trace joins or CASE logic</td>
      <td>Each edge is a visible path</td>
    </tr>
    <tr>
      <td>Performance</td>
      <td>Degrades with complexity and size</td>
      <td>Linear with depth, constant-time per hop</td>
    </tr>
    <tr>
      <td>Maintainability</td>
      <td>Large stored procedures, fragile to schema change</td>
      <td>Schema-free traversal, declarative Cypher queries</td>
    </tr>
    <tr>
      <td>Suitability</td>
      <td>Best for tabular data, not relationships</td>
      <td>Ideal for interconnected, rule-based systems</td>
    </tr>
  </tbody>
</table>



<h2>Real-World Example</h2>
<p>In Neo4j, we can model a Person who holds a Job at a Company. That company is part of a parent hierarchy, and at the top sits a Worldwide OffLimit. If all nodes and relationships are in place, the graph tells us this person is covered — no stored proc required.</p>


<img src="assets/worldwide-restrictions.png">



<p>When a job ends, we remove that node — the graph updates automatically. When a WWOL expires, we remove the edge — all associated people are instantly unaffected. No reprocessing. No snapshot table. No recursion.</p>

<h2>Operationalizing This</h2>
<p>We would use Event Streaming from SQL Server to maintain the graph. Only relevant changes (e.g. job current flag toggles) would trigger updates. Graph changes are fast, append-only, and logged. I’ve already used this approach in EventStream to map foreign key relationships to root entities.</p>



<img src="assets/serverless-pipeline.png" >


<p>Neo4j is the ideal fit for this. It’s mature, widely supported, and already proven in our environment. We could host it ourselves or use GrapheneDB as a managed provider. The existing restriction APIs could be refactored to call the graph service directly, removing the need for persistent badge tables or recalculation logic.</p>

<h2>Why This Is the Right Move</h2>
<ul>
  <li><strong>It’s accurate</strong>: we no longer approximate logic with code</li>
  <li><strong>It’s testable</strong>: every hop and relationship is visible</li>
  <li><strong>It’s maintainable</strong>: fewer lines of logic, more domain alignment</li>
  <li><strong>It’s scalable</strong>: restrictions logic remains constant even as data grows</li>
  <li><strong>It’s finished</strong>: we stop playing whack-a-mole with edge cases</li>
</ul>

<h2>Conclusion</h2>
<p>The current Restrictions system is a patchwork of stored procedures, recursive joins, runtime recalculation, and workaround flags. We’ve stretched the relational model beyond what it was designed for. Restrictions is a graph problem, and we should solve it with graph technology.</p>

<p>I architected the current solution, and I’ve lived through every production incident that followed. I now believe that fully migrating Restrictions to a graph database — powered by clean event streaming from our transactional system — is the only way to close this out with confidence.</p>

<p>This move would modernize the product, improve accuracy, reduce dev effort, and future-proof the platform. It’s the right design for the logic we now own.</p>




<section id="conclusion">
  <h2>✅ Conclusion</h2>
  <p>
    This journey exposed a fundamental misalignment between the system’s growing complexity and the relational model underpinning it. What began as a manageable rules engine gradually evolved into a fragile lattice of stored procedures, temporal logic, and recursive joins. The business problem—evaluating dynamic, multi-dimensional restrictions—demands a data model that mirrors those relationships. A graph-based approach offers the opportunity to model that complexity directly, reduce execution overhead, and deliver clearer logic that’s easier to evolve. <strong>Rethinking Restrictions</strong> isn’t just a technical refactor—it’s a structural realignment between business semantics and system design.
  </p>
</section>



<hr>
<p><em>Authored by John Murphy • GitHub: [your-handle] • LinkedIn: [your-link]</em></p>

</body>
</html>
